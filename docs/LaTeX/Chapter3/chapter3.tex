\chapter{Implementation}	\section{Personalised feed}		The personalised feed is a feed of events that a user has either followed or suggested events based off what other users have followed. The main premise of this function written on the server side and then served by the API the mobile application connects to. To be able to get suggestions the application will retrieve a list of the currently logged in users followed events and then a search of the database for other users that are following one or more of those events. The users followed list is then retrieved which is then parsed, the parsing itself involves grouping the events together and counting how many times these appear then the up to the top 20 events are used to produce the personalised feed. As the mobile application utilised the feed this algorithm is used solely on the server element of the project as data transfer would be high, it gives centralisation to the algorithm and if it needed to be updated it can be with ease, it allows us to use SQL statements to easily filter the data and to cut the processing power needed. This system also does not limit the user to a particular genre or style of event, whereas a tag based suggestion system may do this ultimately allowing the user to see a wider selection of events. 		However this algorithm requires some data to be input by the user and other users to function effectively. Other methods could include a user selecting tags that are of interest to them with the suggestion system working from that data to see what other people have viewed, however this may limit the suggestions to  specific genre/style. A  newly on boarded user will have nothing in their feed, therefore a list of events available in their current area should be presented to them when their suggestions are blank. The system will also have to have some training data with example users and events that are similar to each other, so that the initial users can make use of the functionality. 	\section{Registration and logging in}		When a user was to first open the application they are presented with a login screen, where they are able to input their credentials if they have already registered or it gives them the ability to register a new account by selecting a different screen. The login utilises the OAuth library to authenticate the user and to respond with a access token to access the resources inside the API. However if a user was to input incorrect details they will be presented with an error, all off the validation is conducted on the server side application. This was done as if there was a large security bug or vulnerability in any part of the authentication process it can be patched quickly without the user needing to do anything, such as updating the application of which through Apple can take up to 2 weeks to process an update. If for example the user was to input incorrect credentials then an error message would be returned by the server stating the error, this is then relayed to the view so the user can see where the problem lies. 		During the registration process a user must input their name, email and password, as this is a mobile based application users don't necessarily want to have to type things out multiple times. Therefore they will only type it the once within the `My Profile' view the user will then be presented with the opportunity to update these details if they mistyped/misspelled anything. 	\section{Storing passwords}		The storing of passwords is a topic of constant debate of how best to do it, with considerations to the most secure method and how the data is transferred. The web API supports both HTTP and HTTPS connections, to ensure that no passwords are transmitted over a non-secure connection. However if an attacker was to somehow gain access to the users database table they will be able to see the passwords. To combat this the system will utilise BCrypt to encrypt the password, along with the it will also use a salt to harden the encryption. BCrypt was chosen as it's computationally expensive meaning it takes a while to convert a string into the encrypted version, this will slow down the use of rainbow tables. Also each individual user has their own salt, by doing this the attacker is required to generate a new rainbow table for each user slowing down the process even more. By taking these precautions to slow down the rate an attacker could get the passwords, we could warn users to change their passwords after patching the vulnerability with minimal impact to their services. 	\section{Search functionality}		The search itself was implemented on the device using the built in search bar and search display controller that comes as a pre-set element in XCode 5. The filter is applied after every new character is input to the search field, and to conduct the search it uses the NSPredicate function that will look for a specific string or similar inside of a NSArray. Figure \ref{fig:NSPredicate} shows how you use the NSPredicate function, first you  define how the the filter should operate and then apply it to a NSArray to create a new NSArray. The search function I have implemented searches the event names for a name that contains the input string. This function could be improved by use of multiple conditions to allow more items to be searched, however the description can be very long and a user is already able to filter by venue within the discover area of the application.		The only issue with this method is that it doesn't search everything that's available on the server, only what's currently retrieved to the device. In the future to make this function work more effectively it will need to conduct a request to the server during the search process to retrieve it's results. However this method can be quite heavy as it will need to retrieve the event details along with images to show the results in the standard format resulting in a less responsive and slower user experience. 		\begin{program}			\begin{lstlisting}NSPredicate *resultPredicate = [NSPredicate predicateWithFormat:@"name contains[c] %@", searchText];searchResults = [sortedArray filteredArrayUsingPredicate:resultPredicate];			\end{lstlisting}			\caption{Example of the use of NSPredicate in Objective C}			\label{fig:NSPredicate}		\end{program}	\section{Adding in the following functionality}		To add in the following functionality initially the route `user/following' was used, this route simply outputted all of the event ID's a user was following. When it came to using this feed on the mobile application it quickly became messy, as the mobile application had to 2 retrieve a minimum of two datasets whenever it needed to retrieve event information. Issues where also raised when passing  data between the different views  and having to pass the relevant information from the following array and persisting this data between the views. These 2 datasets where collated into 2 separate arrays and then used in tandem to show if the user was following that event. To help combat this I decided to add in a node inside the returned event information storing a boolean as to whether or not the current user is following that event, then the mobile application will not have to use the 2 different arrays. 		To do this I created a function inside the event model that returned a boolean value dependant on whether the user is following the event or not. Doorkeeper allowed us to use the variable `current\_resource\_owner' this would hold the current users information so initially the idea was to use this inside the model to retrieve the current users information however this variable could only be accessed via the controllers. To combat this issue,  an accessor was created inside the model, this allowed the model to store a bit of information not defined inside the database but defined by the controller. So whenever an event was accessed by a controller the current user was set using the `before\_filter' function. Then to retrieve the following information the `following' function had to be called for each record, this was done by using the `:methods => :following' option of the `render' command making the code to output events to be`render json: @events, :methods => :following'. 	\section{Retrieving events from the jobs}		One of the main parts of the server application is the way it retrieves the events from the various API's. The requirements state it has to be able to do this from multiple API's and to input the data to the same database that's to be used by the API. The main issue being is that each API uses different verbs to describe the data used and different methods to connecting to their API's to retrieve the data. So with that being said, the first step was to find the common ground between the major API's to connect to being Facebook and Google Places. The most basic similarity was they all connect over HTTP and use JSON to respond to requests, this was key as it meant I only had to use the one extra library to connect to the external API's. This was done using the library `httparty' as gave much better error handling over the standard http library bundled with ruby. A function to add in an GET parameters to append to the URL, this was mainly used to define the API key used to access that particular resource. 		A class for each API was then created defining functions that were needed to access the different resources these are named the same and resembles what the function does such as getEvents got the events from that API with certain filters applied to them. Inside of the class a class variable was defined inside of which holds the various filters that can be applied to a request, giving the ability to filter specific events from the system such as events within a particular area. These functions helped with the issue of different API's connect differently, however the response data had to be parsed to match the database structure, so  the `buildEvent' function was defined that simply took in the response hash and outputted it in the correct format for the database to use. 		To create a new interface for a different API it's as simple as using one of the previous API interfaces and replacing the code inside the functions to resemble the correct way of connecting to the new API and it's response format. Once done and saved in the folder where the interfaces are, the administration panel will recognise a new interface and allow you to set up jobs to do retrieve information from the new API. 		The job rake task simply loops through each job applies the filters, inputs the data retrieved assuming it's not already in the database. It uses the ID field from the original data source uses to check if it's currently their, however this needed to be refined as there may be clashes however this is a very unlikely situation and will only result in a missed event. The rake task itself can be ran multiple times and will only add in new events that have been found, however in the future the system needs to be able to recognise changes to the data as well as new data added to be able ensure it's up to date. 	\section{Interoperability}		The method of which to transmit the data was quite a large part of the project, deciding whether to use SOAP or REST required some research into what the API was transferring and how the data was organised. SOAP itself is much heavier standard which is not as lenient as REST requests can be. SOAP requests are also generally requests for outputs from functions on the server such as getting the current stock rates for IBM. However REST is designed for more resource orientated architectures where supplying resources to be used in functions is the main game, bearing this in mind it makes sense to use a RESTFull approach as I want to be getting data and then manipulating it for my view on the mobile application. REST requests are accessed by a specific URI for each resource and can be very logical to what is needed to be retrieved. 		A truly RESTFull API uses heavy linking inside of it's  responses to link to other resources required, as this was mainly designed to link in with a mobile application the linking has been sacrificed for faster processing and data transfer times. However the URI structure to access the different resources, is well defined and logical so this isn't much of an issue.		To respond to the requests I decided to use JSON as this is a much looser notation meaning I get more flexibility on the how the requests and responses are retrieved/sent. Ruby on Rails also has a lot of built-in functionality for parsing and creating JSON strings. As the API could potentially be digested by a wide range of other systems as well it's crucial that the outputting format is readable by many other systems, and JSON offers the best cross language compatibility. 	\section{OAuth}		To help with the authentication process of the application OAuth was used to authenticate users and applications to the API. To get an access token to use the API a user is required to login with their credentials along with a client secret and ID, by using the client secret and ID the system is able to differentiate different code bases utilising the API ultimately giving more fidelity to  any restrictions to the use of the API. OAuth was implemented using the Doorkeeper gem, as OAuth is used for authentication use of the gem is great as it helps to eliminate code based vulnerabilities. Doorkeeper is also an actively worked on open source project so it gets regular updates and bug fixes applied to it. 		To set up the Doorkeeper gem a function was needed inside the User model to authorise that simply returned the user details dependant on if the username/password combination was found inside the database. Once authorised an API access token was issues and this was used in conjunction with all requests to be able to get a response, if this was incorrect then a HTTP 401 code was served denying access to the resource. By use of a different authorisation code for each registered user the system is able to serve data dependant on the current user, allowing the URI /user/feed to be used with a different response for each user. This helped to follow the REST principles by ensuring  the server didn't have to keep a specific state stored for each logged in user. 	\section{Storing user credentials}		The mobile application must be able to store the credentials of a user, to be able to retrieve a new access token when the current one expires. iOS has use of what's called property list (PList) which are similar to an XML file where you can parse in the information wherever you need it around the application, however this PList could potentially be read in by other applications. Or if someone was to get physical access of the device they could read your username/password, and then potentially use that to access other devices. For this reason the system does not utilise PLists to store the data, iOS has a pre built key chain where you are able to store any sensitive information into the application. This information is only accessible by the application so it's a lot more secure than a file that's stored inside the application bundle, the data that resides inside the key chain is also encrypted to ensure it's privacy. To implement this feature a library was used called UICKeyChainStore\cite{keychain}, this was used as again it's a open source project and any bugs or issues can be found quickly which will assist with the overall security of the project.	\section{Evaluation}		Overall the implementation part of the project went well, the odd issue was hit however after analysing the issue and looking at possible workarounds that ended up being better ways of doing it the issues were worked out. Looking back at the proposed requirements of the system, most of the requirements where hit allowing the user to download the application register a new account and view events that are happening around them. The system also retrieved events from external sources and allowed a user to favourite them to allow a personalised feed, with event suggestions. In total the finished product completed the brief of allowing a user to explore events that's happening around them and in new cities.		One requirement that wasn't hit was having the system 100\% location aware, whilst reviewing the data that's retrieved from the API's exact location for events was difficult to retrieve whilst many listed street addresses little longitude/latitudinal information was to hand, meaning the system had to make further requests to a different API to retrieve this information. This was something I didn't have time to implement meaning I had to sacrifice that requirement however the user is still able to view events by city so it doesn't remove the whole purpose of the application