\chapter{Evaluation}

Overall the project went smoothly without hitting any major issues along the way. I found that the server side application took up most of time, even knowing the main project was to produce a mobile application at the end of the project. However it was key that the server infrastructure was there to enable the mobile application to work as expected.

\section{Testing}
	I found that test driven development worked really well for the server side application, being able to write the tests first allowed me to understand what the inputs and outputs where to be for each method. This ultimately gave me a much better understanding of how the inner logic would work, it also allowed me to easily drill down functions to find where code could be reused and abstracted into a separate function. However I did think I could follow the TDD principles much stronger throughout the course of the project, initially I found myself writing the tests first but as I was implementing a function to pass a test I would find some code that would be reused. I would then quickly pop this into a function without writing a test, ending up in having to retrograde the tests for these quick functions I implemented. 

	However when it came to the development of the iOS application I found that TDD became much more difficult because of the target action concept. I found that it was much easier to compile and run the application on the device and then test the newly implemented functionality, to ensure the target was linked together with the action. Throughout the development of the iOS application I also found myself conducting user interface testing, by moving around the elements and seeing what looks good and functions well where. 

\section{Requirements}
	As for fulfilling the requirements I managed to fulfil 13 out of 14 main requirements, however I did end up making the personalised feed a lot simpler than envisaged. This is mainly because the original idea of how the personalised feed was way over complicated and a similar output could be achieved by other methods, this worked nicely as I was able to concentrate my efforts on implementing the other requirements ensuring the resultant project was stable with good quality code. 

	The requirement I didn't implement was sending user notifications when an event was updated, this was primarily because the developer account we were using as part of the Universities development tools didn't support notifications and I was required to purchase a licence to implement this. Also I would have to add in some of version control to where the data was stored to be able read in these changes to the event and distribute the notifications whenever an event was updated. 

	In terms of implementing the other requirements undertaking the modular approach to each section, really helped me to concentrate on the section at hand. By just concentrating on the current feature I was able to ensure the code worked and was efficient at the task it was undertaking, from here I still had a good understanding of how the resultant project was going to fit together as each feature was a logical group of functionality. The overall roadmap helped with this as there was a logical roadmap, almost a waterfall of activities that one part of the system relied on another for the whole project to work. By understanding this I was really able to ensure that everything would work together, and function as required. 

\section{Tools used}
	I was well averse to using Sublime Text  as a code editor and had used it for many other projects, however never for ruby development. The plugins I installed to assist me with the running the tests and snippets allowed me to code as I would inside any other editor. However I did still find myself going to terminal to run commands such as installing new gems and using the generator to generate models/controllers, this wasn't that much of an issue as I had used the terminal before. Some IDEs such as RubyMine already has a GUI to be able to generate code to be used inside the rails project, however I feel that they don't always give you the control you need that a raw text editor does. 

	Heroku allowed me to easily deploy the server application to the server simply by using a git push command to the remote Heroku server, once the new code was copied I could then remotely run things like db:migrate command to update the database and run other rake commands directly on the server from my own terminal. This gave me great control over what was happening on the production server, with other providers you don't always get this control. 

	XCode 5 I found to be a great IDE, it's purpose built for developing for iOS and has some great tools to write the code. The main one I found myself working on was the story board editor being able to drag and drop elements into the view currently being edited was great. Then it was as simple as dragging and dropping a connector to the code to link an element with code, this simplified the process ten fold. With Android you had to name an element and then use the findElementByID function to refer to it which can quickly become messy. XCode also houses a simulator to run your applications inside of, the benefits off a simulator over an emulator are again so much better. Emulators tend to be buggy and can take a long time to boot, whereas the iOS simulator was quick and always ran allowing a much quicker rate of development. 

\section{iOS App}
	The development of the iOS application I found to be a lot more tedious than the server application this I think this was due to not knowing any objective C and only learning it from the online courses put on by Harvard. However after looking into some sample projects on the ray wenderlich site I understood how the applications were structured and how to interact with the elements positioned on the storyboard. I found that Objective C is a very readable language in the way the methods are set out, for example the login method was ` [loginUser:\@``username'' withPassword:\@``Password'']' this method clearly defines what's required as inputs and what the function does. 

	The use of cocoa pods was a nice addition as well, a very similar system to the way Ruby Gems are installed you have a Pod file which defines the libraries that you wish to use and run the command pod install. Once installed you can use the import command to import the library into the location you wish to use it, I opted to use a cocoa pod over the httpRequest library to interface with the API as it gave much better error handling and also transformed the response it an NSDictionary which was a much easier format to deal with.

	I found that developing the GUI for the mobile application to be a lot harder than initially thought, making sure everything was in a place  and presenting the information in a readable format was difficult. The sheer amount of data that was required to be displayed was a lot and needed to be presented in a format that a user would find appealing yet informative, however the wireframes where reminiscent of the how the application ended up looking like which was good. However I did remove the star rating system, as this proved to be quite difficult to implement and wasn't needed for the recommendation system I was implementing.

	Another improvement would be to download the images to be used as part of the mining process and scale and process these images to load a lot quicker onto the mobile application, these images could also be served by the API itself as base 64 encoded images or as image files dependant on business factors.  The images currently being outputted are ones stored on the Facebook severs and are in a larger format than needed for the application itself. 

\section{Server Application}
	The development of the server part of the application overall went well, there was the odd bug with the code but I found following the TDD methodology everything slotted in nicely and just worked well when it came to the integration of each module. Using the Ruby on Rails really helped to accelerate my workflow allowing a lot of helper functions that in other languages I would of have needed to of have written doubling the work load. I also found that the use of Ruby Gems assisted me a lot with the development of the server application in the sense that the use cases I needed code for where already used and people had open sourced solutions for them. 

	However at times I did find I was having to constantly re-run the RSpec tests after every change to ensure they still passed which was a little troublesome and could sometimes take a long time to prepare dependant on the complexity of the tests that where being ran. I did attempt to speed this up by always having a test server running using spork, but the test cases had to still remove the information from the database and re-add the test data every time a test was ran. However this was really not irrelevant to the benefits that I was getting from the TDD approach, overall I found I had a much more usable system than that was originally conceived during the design phase. 

	I also found that when it came to standardising the output of the API ensuring that the requests where the same format I found this to be difficult as I had to change every function that returned an API response. This could of have been utilised with a before\_filter or similar for all API responses, however I didn't start off doing it this way so I ended up doing it the long way. 

\section{User expectations}
	Overall the people that used my application in passing found that the screens where all laid it in a logical manner, and that it was easy to navigate around the application. They also noted that buttons where represented correctly, and they where also self explanatory on what they did. The feed was quite clearly a feed of events that you are following and suggested events, and the overall looks were aesthetically pleasing. The search function is great as it's you don't need to enter a full search string it just searches after every key press. 

	However inside the profile page when clicking on the events being followed table it's expected that when you click on an event you are following it should unfollow the event. Although it currently does not and is somewhat illogical to not do this.  

\section{Reflections}
	If I was to do this project again I would work on ensuring that I wrote tests for the iOS application and making sure that the tests where passable from the offset would of made the the development of the project a lot easier. Also having solid wireframes of how the views where to be set out, this would of have made the overall design of the application a lot more use friendly, and eased the development process as I found I was spending more time worrying about the aesthetics of the application than the functionality of it. 

	I would also make a concious effort to learn any programming languages I hadn't used to a higher level than I did within this project. As I found myself stumbling through the development of the iOS application, as I had never written in objective C before. That being said there where some great resources on the internet and I definitely utilised these, and managed to absorb enough knowledge to be able develop the mobile application. 

	Finally I wouldn't follow TDD for a whole project, it's a great process that worked really well for my server side element, however as stated it didn't work as well when used with the iOS application. Development process are really a mixture between what the project is and personal choice unto how you want to develop the code, however a formal QA  process is necessary to ensure code quality and test cases passing. 
